#+OPTIONS: toc:nil    
#+LATEX_HEADER: \usepackage{parskip}

* Functional Reactive Programming (FRP)

** Imperative or Reactive
The application will in some places refer to some data which will change over
time, due to user input or for other reasons. For example, on the home screen an
element displays the current workspace directory, which initially is ~Nothing~
but will become a ~Just String~ once the user has selected a workspace. Updating
elements to reflect changes in their dependant data can be done in two ways.
First, on change of the data we can update each element which uses that data,
this is the imperative style of doing things. Second, we can define any element
which uses the data to *react* to changes in the data.

*** Imperative

*Element which displays the current workspace.*
#+BEGIN_SRC haskell
textEl <- UI.div # set UI.text "No workspace selected"
#+END_SRC

*Update the element when a workspace is selected.*
#+BEGIN_SRC haskell
on UI.valuechange selector $ \workspace ->
  textEl # set UI.text workspace
#+END_SRC

In the imperative style, when we write an element that depends on changing data
we have to write code that updates the element whenever the data changes. For
example, in the latter code snippet above the user has changed the workspace and
we need to update the text of ~textEl~.

The code to display the element and the code dealing with a change in the data
may be in separate modules, or at least separate to some degree. The fact that
the code dealing with a change in the data has to update any elements which are
dependent on the data, is a violation of the Law of Demeter which says we should
minimize coupling between modules.

Furthermore, the code dealing with a change in the data will need references to
each of the elements it's expected to update, these would need to be passed
either as parameters or monadically. These references are entirely unnecessary,
as we'll find out below.

*** Reactive

*Element which displays the current workspace.*
#+BEGIN_SRC haskell
textEl    <- UI.div
-- The current workspace over time.
workspace <- eWorkspaceBehavior <$> ask
-- A textual representation of the current workspace.
let text =
  maybe "No workspace selected" (\w -> "Workspace: " ++ show w) <$> workspace
element textEl # sink UI.text text
#+END_SRC

*Update the element when a workspace is selected.*
#+BEGIN_SRC haskell
on UI.valuechange selector $ \workspace ->
  emit <- eWorkspaceEmit <$> ask
  emit $ Just workspace
#+END_SRC

In the reactive style, when we write an element that depends on changing data,
we still write code to update that element whenever the data changes. However,
the code updating that element is localised around the code where the element is
written. Notice that the latter code snippet has no reference to the ~textEl~.

In the above code ~workspace~ represents the current value of the workspace as
it changes over time. We then map that value to a textual representation in
~text~, considering that the workspace might not yet be set yet and could be a
~Nothing~. ~sink~ is a utility function provided by the Threepenny-gui library
which updates the attribute of an element as the data changes over time.

When the data needs to be updated, in the latter code snippet, we simply ~emit~
the updated value. No longer do we have to worry about updating all the elements
in our code base which depend on said data, or worry about having references to
these elements. We are no longer violating the Law of Demeter.

** FRP in More Detail
  
What is a Behavior etc..

** FRP Architecture in UTP²

Where possible UTP² is written in reactive style. Any data of type ~a~ which may
change over time is by a ~Behavior a~. The data might not have an initial value
in which case we represent it by a ~Behavior (Maybe a)~. If we want the freedom
to access and update a ~Behavior~ across the codebaseIn the initial setup code
we initialize the environment with

Wherever we require the data we can access it by asking for the respective
~Behavior~:

#+BEGIN_SRC haskell
workspace <- eWorkspaceBehavior <$> ask
#+END_SRC

~Behavior~ is an instance of ~Functor~ which means we can map over the current
value of a ~Behavior~, manipulating it as necessary:

#+BEGIN_SRC haskell
workspace <- eWorkspaceBehavior <$> ask
#+END_SRC

To update
