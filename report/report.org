# Set documentclass in org. Otherwise if we set it in preamble then org will
# generate a second documentclass itself, causing a LaTeX compiler error.
#+LATEX_CLASS: report

# Include LaTeX preamble.
#+LATEX_HEADER: \include{settings/preamble}

# 12pt font.
#+LaTeX_CLASS_OPTIONS: [12pt]

# We generate our own table of contents, so suppress the default one.
#+OPTIONS: toc:nil

# Begin LaTeX ##################################################################

# Preliminary pages.

\include{tcd/titlepage}
\pagenumbering{roman}
\setcounter{page}{1}
\include{tcd/declaration}
\include{tcd/permissiontolend}
\setcounter{page}{3}
\include{abstract}
\setcounter{page}{4}
\include{acknowledgements}
\tableofcontents
\newpage

# Prepare for body of report.

\pagenumbering{arabic}
\setcounter{page}{1}

# End LaTeX ####################################################################

* Background

** Existing Software

\utp{} is an existing computer application which is a Theorem Proving Assistant
for the Unifying Theory of Programming. "Theorem Proving Assistant" means it can
be used to assist the development of theorems, the theorems in question are
related to the "Unifying Theory of Programming". The application is written in
Haskell, with a graphical user interface (GUI) built with the mature wxHaskell
library. \utp{} has been in development since at least March 2010 when the
source originally appears on BitBucket, cite:SaoithinInitialCommit. \utp{} was
formerly known as SaoithÃ­n.

WxHaskell is a GUI library for Haskell that was started as early as July 2003,
cite:wxHaskellInitialCommit. Though wxHaskell's official history only begins in
January 2007 when the project was taken over by a new set of maintainers,
cite:OldwxHaskellnews. The goal of wxhaskell is to provide an industrial
strength GUI library for Haskell, the wxHaskell team attempt to do so by
building on top of an existing GUI library, and thus avoid the majority of the
burden of developing a GUI library themselves, cite:leijen2004wxhaskell.

#+CAPTION: Existing \utp{} home screen.
#+NAME: fig:existing-utp-home-screen
[[./images/existing-utp2-home-screen.png]]

** Existing Issues
*** Object Oriented Concepts

wxHaskell is built on top of an existing GUI library called wxWidgets. However
wxHaskell is a GUI library for Haskell and wxWidgets is a GUI library for C++,
and Haskell and C++ are very different languages, Haskell is a functional
programming language and C++ is an object oriented language. Unfortunately
wxHaskell exposes the object oriented concept of inheritance to the programmer
and wxHaskell code is typically written using about twenty percent low level
bindings to wxWidgets.

In wxWidgets inheritance is used to describe the type of many components. For
example a button in wxWidgets has a type ~wxButton~ but it has many layers of
inheritance as you can see in the image below. Because wxHaskell is a wrapper
around wxWidgets some concepts from wxWidgets appear in wxHaskell, in the case
of a button its type in wxHaskell is ~Window (CControl (CButton ()))~ which
encodes some of the inheritance relationship.

wxHaskell consists of four key libraries, only two of which are typically used
by a wxHaskell programmer. The lesser used of these is wxcore which provides
low-level Haskell bindings to wxWidgets. The more used is wx which is a set of
higher-level wrappers over wxcore. Most wxHaskell software is about eighty
percent wx and twenty percent wxcore, cite:wxHaskellWiki.

We have described how wxHaskell exposes object oriented concepts of the
wxWidgets library which it wraps, both through encoding inheritance and the
low-level bindings of wxcore. This is unfavourable because as programmers we
have some choice in the languages we use, we choose a language because of
features that appeal to us. We might choose a functional language like Haskell
because features of the language such as lazy evaluation and higher-order
functions allow us to write highly modular programs, programs that are much
smaller and easier to write than conventional ones, cite:hughes1989functional.

While we can argue the merits of functional programming it is worth noting that
Haskell and C++ are two solutions to different problems, they each solve their
share of problems equally well. Haskell provides a high level of abstraction and
few runtime errors while C++ provides fast execution time and a lot of library
support. However if you have chosen a language to work with you should be able
to stay within its constructs and paradigms.

# Inheritance is a feature from object oriented languages and is not generally
# dealt with in functional programming. Consider in an object oriented language a
# type ~FooA~ which inherits from ~Foo~. If we wanted to model something similar
# in a functional programming language like Haskell, but avoiding any object
# oriented concepts, then we could write a function ~foo~ which returns data of
# type ~Foo~ and then write a function ~fooA~ which internally calls ~foo~ but
# modifies the data (a ~Foo~) first before returning a ~FooA~. The key point here
# is that we do not need inheritance to get the data we ultimately want to
# represent, both languages simply present different techniques for representing
# and modifying the data.

*** Difficult to Install

# TERM sandbox

Ease of downloading and installing libraries into sandboxes has become a staple
of modern languages, with many modern languages like Rust, Swift and Elixir
shipping with powerful package managers that automate this process. Haskell has
made progress on this front with the Haskell package manager Stack.

Before Stack existed it was not uncommon to be stuck with dependency conflicts
between libraries that your project depends on. Dependency conflicts occur when
libraries have conflicting version bounds on some mutually required library. For
example if library-a requires library-c > 0.7 but library-b requires library-c <
0.7 then we have a dependency conflict since no version of library-c can satisfy
both conditions. You might end up changing the version of library-a to a
previous version that requires library-c 0.6 which then satisfies both
conditions, however, now library-a also requires library-d 0.5 but library-c
requires library-d > 0.6. This endless cycle of fixing dependency conflicts is
commonly referred to as Cabal hell.

The Haskell tool Stack solves Cabal hell by providing sets of libraries which
are guaranteed to work together without dependency conflicts. These sets of
libraries are called resolvers and every week on Sunday night a new stable
resolver is released. Using Stack we can easily add a dependency to a Haskell
project by simply listing it in the project's dependencies. The next time the
project is built using Stack the new dependency will automatically be downloaded
and built to a location in a sandbox designated for the project.

wxHaskell is not in the current Stack resolver (we commonly just say "in
Stack"). This means if we want to build our project with the tool Stack, then
wxHaskell has to be listed as an additional dependency, and there are no
guarantees of avoiding conflicts with wxHaskell's dependencies. At the beginning
of this final year project \utp{} was not building with Stack at all but rather
had to built by directly invoking the GHC compiler. Andrew Butterfield later
succeeded in getting the project building with Stack, the significance of which
is reflected in the respective commit message:

# TERM commit message

#+BEGIN_QUOTE
"UTP2 NOW BUILDS WITH stack ON OS X 10.11.16 !!!!" 
#+END_QUOTE

It is worth noting two things here. One is that the difficulty of getting \utp{}
to build with Stack was because of dependencies like wxHaskell which are not in
Stack and caused dependency conflicts. The second is that there are benefits to
Stack apart from its resolvers, including isolated and reproducible builds, and
an easy to use command line interface.

However installing wxHaskell is not /just/ a matter of resolving dependency
conflicts. We also need to install the C++ library wxWidgets which wxHaskell is
a wrapper around. The instructions for installing wxWidgets are different per
platform due to their not being a well-established C++ package manager.
Furthermore, on macOS, installing wxWidgets requires an install of the
application XCode which on my machine weighs in at 10.46GB.

*** Difficult to Package

To distribute \utp{} it would be beneficial to be able to produce a standalone
application e.g. a ~.deb~ package for Debian or ~.app~ bundles for macOS, or if
not standalone applications then at least executables. On macOS there were
difficulties in building the project, largely related to wxHaskell for reasons
discussed in the previous section 2.2.

#+BEGIN_QUOTE
"Students at TCD have successfully built it on Linux (Ubuntu). It should run in
principle on Max OS X as well, but I have not been able to get this to work
(help would be appreciated)."

-- cite:SaoithinHomepagea (Note that this webpage is somewhat outdated).
#+END_QUOTE

*** Conclusion

In respect of the object oriented concepts exposed by the wxHaskell library, the
difficulty in installing \utp{} and of creating standalone applications -- in
both of which wxHaskell plays a role -- we decided to explore the building of a
second GUI for \utp{} using an alternative GUI library, one we hoped would
alleviate the problems associated with wxHaskell.

** A New Hope
*** Haskell GUI Libraries

Unfortunately the state of GUI programming in Haskell is not in a great place.
There do exist many GUI libraries but they tend to fall into one of two
categories. Some provide direct access to GUI facilities through bindings to an
imperative library, others present more high-level programming interfaces and
have a more declarative, functional feel, cite:courtney2001genuinely. wxHaskell
falls into the first category, of bindings to an imperative library. Most of the
more powerful GUI libraries fall into this category, because they can leverage
the power of the imperative language they provide a binding to. Libraries in the
second category, high-level libraries, tend to not provide GUI support directly
but rely on a library like wxHaskell to provide the necessary GUI bindings.

#+BEGIN_QUOTE
"There is a large number of GUI libraries for Haskell. Unfortunately there is no
standard one and all are more or less incomplete. In general, low-level veneers
are going well, but they are low level. High-level abstractions are pretty
experimental. There is a need for a supported medium-level GUI library."

-- cite:HaskellWikiGuiLibraries 
#+END_QUOTE

*** \thp{}

# How Threepenny fits into the Haskell GUI scene.
\thp{} is a GUI library for Haskell which falls into the previously mentioned
second category, it provides high-level abstractions with a declarative,
functional feel. However it does not rely on another library like wxHaskell to
provide GUI bindings, \thp{} is a stand-alone GUI library. As a stand-alone GUI
library \thp{} does not rely on any non-Haskell dependencies, in stark contrast
with wxHaskell.

# Avoiding GUI dependencies.
How does \thp{} display things on-screen? \thp{} does not create bindings to any
system calls to display a GUI, this means that \thp{} applications are not
standalone applications. \thp{}'s key distinguishing factor is that
it uses the web browser as a display. Web pages like docs.google.com are
examples of powerful web applications, applications that use the web browser to
display a GUI. There are many powerful web applications that provide an
experience that is not compromised because the application was written as a web
application instead of as an standalone application. A notable part
of the experience when using a web application like Google Docs is that an
installation is not required, a web browser which is the necessary software to
display the GUI, is something which most people already have installed. \thp{}
manages to avoid relying on another Haskell library for GUI bindings, and
manages to avoid any non-Haskell dependencies. It does so by requiring a piece
of software to display a GUI that most people already have installed, a web
browser.

# Easy installation.
Because \thp{} manages to avoid GUI related dependencies, by using the web
browser as a display, the pain of installing these dependencies is removed and
installing \thp{} is easy. At the time \thp{} was chosen it was not in Stack,
however only one of its dependencies was not in a Stack. Once a library's entire
dependencies are in Stack it is trivial to get that library in Stack. A few
weeks after discovering \thp{} it was in the latest Stack resolver.

# Full power of modern web development.
Because \thp{} uses the web browser as a display, this means that what is being
rendered to the user is ultimately just HTML and CSS. How \thp{} works is that
it provides functions to write and manipulate HTML, it also allows the
programmer to load CSS files and to run JavaScript. How \thp{} works will be
explained in more detail later on but in essence it is a wrapper around the
languages of modern web development, this means the full power of modern
development can be leveraged in a \thp{} application. Another benefit of \thp{}
being a wrapper around HTML, CSS and JavaScript is that if you are familiar with
these web development technologies then \thp{} has a relatively gentle learning
curve compared to other Haskell GUI libraries.

# FRP.
We have mentioned that \thp{} provides high-level abstractions, with a
declarative, functional feel. This is largely due a concept called Functional
Reactive Programming (FRP) which is at the heart of \thp{}. FRP will be
explained in more detail later on, for now it is sufficient to know that FRP is
a style of programming which is very much in line with the functional
programming ideology, of declarative high-level semantics. Heinrich Apfelmus is
the author of a popular FRP library for Haskell named Reactive-banana. He also
authored \thp{} and uses it to explore the application of FRP to building a GUI,
cite:Reactive-bananWiki.

*** \thp{} for \utp{}
    
# Why Threepenny summary.
\thp{} was chosen for \utp{} because of the above reasons. It is easy to
install, in stark contrast to wxHaskell. It has a gentle learning curve if you
are already familiar with web development technologies. Finally, the strong
focus on FRP within \thp{} promotes writing a GUI in a declarative manner, in a
style in-line with the functional programming ideology.

# Young, flawed but maintainable.
While \thp{} has these many benefits it is still a young library and would
likely have some flaws, which would later be confirmed. \thp{} was only started
in July 2013 and at the current time of writing is on version 0.7.1. However,
for a functioning GUI library \thp{} has quite a small code base which makes it
easier to get involved and find solutions to these flaws. The small code base
also means that \thp{} is very maintainable which is vital for its longevity.
Part of the reason for the small code base is the fact that \thp{} leverages the
power of existing web development technologies, letting these existing and
widely prevalent technologies do the heavy lifting.

** \thp{}

*** Introduction

As the project progressed flaws of \thp{} were discovered and addressed. This
required making modifications to \thp{}'s source code. In light of this it is
beneficial to have a deeper understanding of how \thp{} operates, which will
make understanding \thp{}'s flaws and how they were addressed much easier later
on. This chapter provides an overview of how \thp{} operates and then provides
an in-depth walk-through of a small \thp{} application.

*** Overview 

# Browser as a display.
\thp{} uses the web browser as a display. This means that a user views a \thp{}
application in their browser, and what is rendered in their browser is HTML and
CSS, which can be manipulated by JavaScript. To solidify the idea that a \thp{}
application is ultimately HTML, Figure [[fig:threepenny-is-html]] shows a simple
\thp{} application being displayed in a browser. The browser's developer tools
are open, showing the HTML structure of the application.

#+CAPTION: A \thp{} application is ultimately HTML.
#+NAME: fig:threepenny-is-html
[[./images/threepenny-is-html.png]]

# Manipulations by JavaScript.
The screenshot above shows how a \thp{} application consists of HTML. However it
only shows a static view of the application and applications generally need to
be dynamic; the displayed HTML needs to be able to change in structure, in
response to user input for example. These manipulations are done in the browser
by JavaScript. Any \thp{} code which manipulates displayed elements is converted
from Haskell to JavaScript and evaluated in the web browser. For example we
might want to append a list item ~<li>~ with text "Ferrari" to a list ~<ul>~ of
car names, and have written the appropriate Haskell code (below). At runtime
this Haskell code is converted to JavaScript and evaluated in the browser.

#+CAPTION: Appending to a list in \thp{}
#+BEGIN_SRC Haskell
UI.ul #+ [UI.li # set UI.text "Ferrari"]
#+END_SRC

# Event loop.
So far we have covered the ideas that \thp{} applications are displayed using
HTML and CSS in a web browser, and that manipulations occur by converting
Haskell code to JavaScript and evaluating it in the web browser. One important
question is how a \thp{} application knows when to apply the manipulations, when
to evaluate the JavaScript? For example we might only want the colour of a HTML
element to change when the user presses a specific button, in this case we are
waiting for input from the user and once that input is received JavaScript is
evaluated. Wherever our \thp{} application is interested in a certain event,
such as a user pressing a button, interest in that event is registered with the
web browser which is displaying the application. Whenever the event occurs in
the browser, the \thp{} application is informed and may send additional
JavaScript code to the browser to be evaluated.

*** Walkthrough

# Overview.
We now have an overview of how a \thp{} application is displayed in the browser,
including conversion to JavaScript code and how browser events such as button
clicks are handled. We will now look at the life-cycle of a \thp{} in more
detail, by looking at a minimal working \thp{} application. While working our
way through the application we will be referring to Figure [[fig:thp-life-cycle]]
below which describes the life-cycle of a \thp{} application.

#+CAPTION: Life cycle of a \thp{} application.
#+NAME: fig:thp-life-cycle
[[./images/threepenny-run-ui.png]]

#+CAPTION: \thp{} applications are served by a local server.
#+NAME: fig:local-server
[[./images/local-server.png]]

# Overview of minimal application.
The Haskell code of the \thp{} application we will walk-through is in Listing
[[list:minimal-app]] below. The first line of ~app~ creates a button with text
"Click me!". In the second line we attach that button to the HTML ~<body>~. The
third line causes its body to be evaluated when a user clicks the button. The
fourth line is evaluated when a user clicks the button, changing the button's
text to "I have been clicked!".

# TERM boilerplate

#+CAPTION: A minimal \thp{} application.
#+NAME: list:minimal-app
#+BEGIN_SRC haskell
app = do
  button <- UI.button # set UI.text "Click me!"
  askBody #+ [element button]
  on UI.click button $ \(x, y) ->
    element button # set UI.text "I have been clicked!"
#+END_SRC

# First two arrows, initial HTML.
We have described the application code at a high-level, now we will look in more
detail at what occurs at runtime. When we execute the compiled code a local HTTP
server is started, the server serves our \thp{} application at the address
~localhost:8000~ by default. We can visit this address in our browser to view
our \thp{} application. When we visit ~localhost:8000~ in our browser a HTTP GET
request is sent to the server and the server responds with an HTML file, this
HTML does not yet contain any HTML describing our \thp{} application. This HTTP
GET request and the response correspond to the first two arrows in our life
cycle diagram.

# Third arrow, WebSocket connection.
Included in this initial HTML file is some JavaScript which is evaluated in the
browser, it opens a connection to the server. This is the third arrow in our
life cycle diagram. The type of connection opened is called a WebSocket
connection, which stays open until the user closes their browser tab. The
benefit of maintaining an open connection between the server and the browser is
that the server can send data to the browser whenever it wants to, this means
the server can update what is being displayed at any time. For example we might
want to set a button to a red colour after a timer expires. Because a WebSocket
connection is open, the server can send JavaScript code to the browser when the
timer expires, this JavaScript code is evaluated in the browser and sets the
button to a red colour. To further see why maintaining an open connection is
important we can consider the traditional alternative to a WebSocket. In a
traditional web application the browser sends HTTP requests to the server and
the server responds, the server can only send data to the browser in response to
a browser's HTTP request. Considering our timer example, for the browser to know
when the timer has expired the browser would have to be constantly polling the
server.

# Application evaluation, fourth arrow.
Continuing with our example application, once the WebSocket connection has been
opened our \thp{} application code is evaluated, this corresponds with the
fourth arrow in our life cycle diagram. In the second line of ~app~, JavaScript
code is sent from the server to the browser to be evaluated, this code adds the
button element from the first line to the HTML ~<body>~. In the third line the
server tells the browser that it should be informed of any clicks on the button,
in other words we are registering an event handler that is triggered by clicks
to the button.

# Event loop.
Finally we will consider the loop in the life cycle diagram. The browser informs
the server whenever the button click event occurs, this corresponds to the fifth
arrow in the life cycle diagram. When the server receives this information the
fourth line of ~app~ is run, sending JavaScript code to the browser to change
the button's text to "I have been clicked!" which corresponds to the final arrow
of the life cycle diagram. This event loop will continue until either the user
closes the browser tab or the server is killed.

* Implementation

** A Right-Click Menu

*** Background

# Why right-click menu first.
Right-click menus are widely used in the existing \utp{} application, Figure
[[fig:existing-utp-home-screen]] shows an example of a right-click menu on the
application's home screen. Building a custom right-click menu using \thp{}
represented, to some degree, an investigation into the feasibility of using
\thp{} to build an entire GUI for \utp{}. This is both because a right-click
menu is one of the more complex components of a GUI and also because of the
widespread use of right-click menus in \utp{}.

# Not supported by Threepenny-gui. 
\thp{} does not provide a facility to build a right-click menu. You might
expect, that a GUI library would provide support for building a right-click
menu, since it seems like one of the fundamental parts of a GUI. However
\thp{}'s approach is different to a traditional GUI library, it acts as a
wrapper around existing web technologies, leveraging their power. This means
that the problem of building a right-click menu in \thp{} is more of a problem
of building a right-click menu using web technologies.

# Right-click menu using web technologies.
Building a right-click menu using web technologies is not entirely
straightforward either. There exists a HTML specification for building a
right-click menu, cite:HtmlLivingStandard. However at the time of writing it is
only enabled by default by Mozilla's Firefox browser. Google's Chrome browser
and Apple's Safari have implemented the specification however is must be enabled
via a developer flag, and Microsoft's Edge does not support the specification.

*** Implementation

# contextmenu event introduction.
While most major browser's do not, at least by default, support right-click
menus based on the HTML specification, all major browsers support the JavaScript
~contextmenu~ event which can be used to build a right-click menu, albeit with a
bit more work. JavaScript events, in particular the ~contextmenu~ event and how
it can be used to build a right-click menu is explained below.

# Event propagation.
HTML consists of a tree of elements such as ~<body>~, ~<p>~ or ~<button>~, an
example of HTML's tree structure is shown in Figure [[fig:html-tree]]. When a
JavaScript event occurs at one of these elements it propagates upward through
the tree of elements; downward propagation is also possible, though upward
propagation is most common. For example when a user clicks on an element a
~click~ event is fired at that element and propagates upward through the tree of
elements. JavaScript event handlers can be bound to elements, such that when an
event propagates through an element it can trigger an event handler. This idea
of event propagation and handling is very similar to the idea of exception
propagation and capturing which is found in most programming languages.

#+CAPTION: Tree structure of a HTML document.
#+NAME: fig:html-tree
[[./images/html-tree.png]]

# The contextmenu event.
According to Mozilla's documentation, "The ~contextmenu~ event is fired when the
right button of the mouse is clicked (before the context menu is displayed), or
when the context menu key is pressed", cite:MozillacontextmenuEvent. This simply
means that the ~contextmenu~ event is fired when a user right-clicks, the
context menu key mentioned refers to the fact that a user can simulate a
right-click on some keyboards. An event handler for a ~contextmenu~ event is
thus a function that will only be evaluated when a user right-clicks.

# Design overview.
To build a right-click menu we need to know two important things, when a user
right-clicks on an element and the coordinates of the right-click. If we know
when a user has right-clicked on an element then we know when to display our
right-click menu, if we know the coordinates of the right-click then we know
where to display our right-click menu.

# Design.
To solidify our goals: we want to display a custom right-click menu R when a
user right-clicks on a element E. Our approach to building this right-click menu
is to write an event handler that is triggered by a ~contextmenu~ event fired by
the element E. When this event handler is evaluated we will display a custom
right-click at the coordinates given in the ~contextmenu~ event. The right-click
menu we will display will simply be built from standard HTML elements such as
~<div>~, with some styling.

# Implementation.
We previously discussed writing an event handler in the background section on
\thp{}, the relevant code is shown again below in Figure
[[fig:button-click-handler]], here the event handler created would be triggered by a
~click~ event fired by the ~button~ element. To build a right-click menu we want
to accomplish something similar but our event handler needs to be triggered by a
~contextmenu~ event instead of a ~click~ event. The problem was, at the time,
\thp{} did not provide a ~UI.contextmenu~ function similar to ~UI.click~.

# TERM Pull Request

#+CAPTION: Registering an event handler for clicks on a button.
#+NAME: fig:button-click-handler
#+BEGIN_SRC haskell
on UI.click button $ \(x, y) ->
  -- event handler body
#+END_SRC

# Pull Request.
A pull request is a request to merge code with an existing code base. We sent a
pull request to the \thp{} repository which added a ~UI.contextmenu~ function to
\thp{}, the pull request was accepted and the code is now part of \thp{}. Now
with ~UI.contextmenu~ it is possible to create event handlers that are evaluated
when a user right-clicks an element.

# threepenny-gui-contextmenu.
Now that \thp{} supports writing event handlers for ~contextmenu~ events the
next step is to write a library which leverages that capability and allows a
user to build right-click menus. We built a library called \tgc{} which is
publicly available and provides this functionality. The README of \tgc{} is
included as an appendix.

#+CAPTION: A right-click menu in \utp{} using \thp{}.
#+NAME: fig:right-click-thp-utp
[[./images/right-click-threepenny-utp.png]]

*** Feasibility 

Implementing \tgc{} was not straightforward, even after ~UI.contextmenu~ had
been added to \thp{}. Conditions had to be taken into account which were not
initially considered, for example when our \tgc{} event handler is triggered on
a right-click, we need to prevent the ~contextmenu~ event from propagating
further, otherwise the standard browser right-click menu would also be shown in
addition to our custom right-click menu. Another difficult case when a user's
mouse leaves a right-click menu, all nested menus are closed but the root menu
remains open, as shown below in Figure [[fig:leave-right-click-menu]].

#+CAPTION: Leaving a nested right-click menu.
#+NAME: fig:leave-right-click-menu
[[./images/leave-right-click-menu.png]]

We mentioned at the beginning of this chapter that building a custom right-click
menu using \thp{} represented, to some degree, an investigation into the
feasibility of using \thp{} to build an entire GUI for \utp{}. Considering the
difficulties in doing so, it raises the question of whether \thp{} is a feasible
choice for building a GUI for \utp{}? Our answer is that it is and that answer
is justified as follows. While implementing a right-click menu was difficult, it
also was possible, this serves as an indicator that we can use \thp{} as an
alternative to wxHaskell. More importantly however, while implementing a
right-click menu we managed to contribute to \thp{}'s source code. Considering
the poor state of the Haskell GUI space, the fact that we can contribute to a
library like \thp{}, and ever so slightly improve the state of the Haskell GUI
space, is a large positive.

** Layout

*** Background

# An unavoidable consideration.
What is displayed in a GUI is, at a high-level of abstraction, simply a set of
elements in a certain layout. For example a GUI might consist of a navigation
bar above a main viewing area, a simple two element layout. Each of these two
elements might again consist of a layout of further elements, for example the
navigation bar might consist of multiple tabs in a horizontal layout. Layout is
simply an unavoidable consideration when building a GUI.

# Curse of CSS.
HTML and CSS are powerful tools which allow us to create complex layouts,
however the means to do so can also be complex. \thp{} leverages the power of
these web technologies meaning that any layout which is possible using HTML and
CSS is also possible in \thp{}. While HTML and CSS are powerful tools they can
also be confusing, especially for those who are only looking for a GUI library
in Haskell and are unfamiliar with HTML and CSS.

#+BEGIN_QUOTE
"You have all capabilities of HTML at your disposal when creating user
interfaces. This is a blessing, but it can also be a curse, so the library
includes a few layout combinators to quickly create user interfaces without the
need to deal with the mess that is CSS."

-- cite:Threepenny-guiWiki
#+END_QUOTE

# HTML table image.

# Threepenny's limited layout combinators.
The layout combinators (functions) that \thp{} provide allow us to layout
elements in tables, where each element is contained in a cell of the table.
These tables are displayed in the browser using ~<table>~, ~<tr>~ and ~<td>~
HTML elements. HTML tables have long been the de facto standard for writing
layouts in HTML documents. However they have limitations; in particular HTML
table layouts are not responsive, elements have a static size that will not
change based on screen size. Heinrich Apfelmus acknowledges their limitation,
stating that they "tend to behave unpredictable, especially when content size
changes dynamically".

*** Flexbox

# Power of Flexbox.
Flexbox, is a CSS specification for writing responsive layouts, it allows
elements to grow to fill available space, or to shrink to avoid overflow,
cite:atkins2013css. We can also do more complex things like specify that
elements should have sizes according to a certain ratio, or have elements wrap
onto new lines if there is not enough space on the current line.

#+BEGIN_QUOTE
"In the flex layout model, the children of a flex container can be laid out in
any direction, and can âflexâ their sizes, either growing to fill unused space
or shrinking to avoid overflowing the parent. Both horizontal and vertical
alignment of the children can be easily manipulated."

-- cite:atkins2013css 
#+END_QUOTE

#+CAPTION: Using Flexbox to wrap elements onto a newline.
[[./images/flex-wrap.png]]

*** Implementation

# Justification.
Heinrich Apfelmus appears in favour of Flexbox, writing that Flexbox "apperas to
solve most of the layout woes. Flexboxes may be a good start for implementing
proper layout combinators in Haskell", cite:Threepenny-guiIssue70. Because
Flexbox would allow us to write responsive layouts for \utp{} and because it is
a direction for \thp{} that Apfelmus in in favour of, we decide to write a
library to add Flexbox support to \thp{}.

# Flexbox properties.
Flexbox is a CSS specification, this means Flexbox layouts are written using CSS
properties. To write Flexbox layouts, it is simply a matter of applying the
correct CSS properties to a parent element and its children elements. Figure
[[fig:flex-ratio]] shows three elements in a ratio of 1:2:1; this is a responsive
layout written with Flexbox, meaning that the ratio of the elements will be
maintained on different screen sizes. The HTML code with the necessary CSS
properties to achieve Figure [[fig:flex-ratio]] is shown in Listing [[list:flex-ratio]],
note that some additional styling code is not shown.

#+CAPTION: Three elements in ratio 1:2:1
#+NAME: fig:flex-ratio
[[./images/flex-ratio.png]]

#+CAPTION: HTML code for Figure [[fig:flex-ratio]]
#+NAME: list:flex-ratio
#+BEGIN_SRC html
<div style="display: flex;">
  <div style="flex-grow: 1;">foo</div>
  <div style="flex-grow: 2;">foo</div>
  <div style="flex-grow: 1;">foo</div>
</div>
#+END_SRC

# threepenny-gui-flexbox.
We published a library called \tgf{} which is in Stack. \tgf{} provides a method
of writing Flexbox CSS properties and converting them to the format expected by
\thp{}, also included in the library are functions which provide abstractions
for common patterns. For more detail \tgf{}'s README is attached as an appendix.
The code to achieve Figure [[fig:flex-ratio]] using \thp{} and \tgf{} instead of
HTML is shown in listing [[list:flex-ratio-tgf]], again note that some additional
styling code is not shown. \tgf{} is used in our \thp{} implementation of \utp{}
to ensure the theory graph remains maintains the window's width and to ensure
the theory graph nodes are centered, as shown in Figure [[fig:thp-utp-home]].

#+CAPTION: \thp{} code for Figure [[fig:flex-ratio]]
#+NAME: list:flex-ratio-tgf
#+BEGIN_SRC haskell
UI.div # setFlex parentProps #+ [
    (UI.div # set UI.text "foo" # setFlex (flexGrow 1))
  , (UI.div # set UI.text "foo" # setFlex (flexGrow 2))
  , (UI.div # set UI.text "foo" # setFlex (flexGrow 1))
  ]
#+END_SRC

** File Selection

*** Background

# TERM existing \utp{} application.

# Directory selection necessary.
When a user runs the existing \utp{} application for the first time the first
window presented to the user is a file selection dialog. The dialog asks the
user to select a directory, which will be the application's workspace. The
workspace is a directory which contains files that persist application state.
Because of their existing use in \utp{}, it is necessary to be able to implement
directory selection dialogs with \thp{}.

# Not a Threepenny problem, a HTML problem.
\thp{} does not itself present any facilities for implementing directory
selection. This again, similar to a right-click menu, seems like fundamental
functionality that a GUI library should provide. In fact to implement directory
selection, we must take a similar approach as we did with building a right-click
menu. Because \thp{} is a wrapper around existing web technologies, the problem
of implementing directory selection with \thp{} is instead a problem of
implementing directory selection using web technologies.

# TERM web technologies.

# A HTML solution.
Directory selection and file selection are very similar as far as a user is
concerned, in both cases the user is presented with a window like the one in
Figure [[fig:thp-workspace-dir]], the only difference is the limitation of what the
user is allowed to select. In HTML, the code for a directory selector and file
selector are very similar, in fact a directory selector is simply a file
selector with one additional attribute, see listings [[list:html-file-selector]] and
[[list:html-directory-selector]]. For this reason we will first attempt to build a
file selector in \thp{}.

#+CAPTION: A file selector in HTML.
#+NAME: list:html-file-selector
#+BEGIN_SRC html
<input type="file">
#+END_SRC

#+CAPTION: A directory selector in HTML.
#+NAME: list:html-directory-selector
#+BEGIN_SRC html
<input type="file" webkitdirectory>
#+END_SRC

*** Solution

# Incorrect file path.
We can quite easily write a \thp{} application that results in a file selector
as in listing [[list:html-file-selector]], and prints the path of a selected file to
stdout. Unfortunately, when running the application this will not print the file
path we expect to stdout. When a user runs the application and selects a file
such as ~/Users/foo/bar.txt~ the file path ~C:\fakepath\bar.txt~ is printed to
stdout.

# Browser security.
The reason that ~C:\fakepath\foo.txt~ is printed to stdout is because of a
security feature that is present in all major browsers. If we are browsing a
webpage, are prompted to select a file, and select a file, the server will only
receive the file contents and the file name. The file path is obfuscated to
appear as ~C:\fakepath\<name>~ where ~<name>~ is the file name. The reason for
not revealing the full file path is so that the server cannot learn about the
file system structure of a user. For example if the server were to receive a
file path such as ~/private/foo/bar.txt~ then the server is aware of the
existence of the directories ~/private~ and ~/private/foo~ on the user's file
system, information the user might not have intended to share.

# Makes no sense for a local server.
A local server is a server on a user's own machine, while a remote server is
located on another machine. When browsing a webpage served by a remote server
the browser security feature that obfuscates file paths makes sense, it is a
security concern to be sharing details of our filesystem with a remote server.
Recalling from the background chapter on \thp{}, a \thp{} application uses a
local server to serve the application as a webpage, see Figure
[[fig:thp-life-cycle]] and [[fig:local-server]]. In this case of browsing a webpage
served by a local server the browser security feature does not make sense. We do
not want to hide file paths from our own application.

# Remove the security feature.
In order for a \thp{} application to receive the correct file path, the user
needs to view the application in a browser which does not obfuscate the file
path. We can solve this by shipping a browser as part of our \thp{} application
which has this security feature removed, this solution is discussed in the next
chapter.

** Electron

*** Background

# What is Electron?
Electron is a framework for creating standalone applications with web
technologies. To display applications, Electron uses a modified version of the
Chromium browser. Of particular interest, Electron's modified browser removes
many security features found in most browsers. Included in the removed security
features is file path obfuscation. This means that when a user is browsing a
webpage through Electron's browser and selects a file, the server serving the
webpage will receive the correct file path and not something of the form
~C:/fakepath/<name>~.

# Electron fixes file selection, and consistent user experience.
Our goal is to integrate Electron with our \thp{} application, so Electron's
browser displays the application. After integrating Electron we can correctly
implement file selection because Electron's browser does not obfuscate file
paths, allowing the \thp{} server to receive correct file path. Another benefit
of displaying \thp{} applications with Electron's browser is a consistent user
experience. The reason for this is that all users would be viewing our \thp
application using Electron's browser; instead of their own installed browser,
which may be different for each user. Browser's have different levels of support
for web standards which results in a inconsistent user experience. Table
[[table:browser-support]] shows scores of different browsers for their support of
the HTML 5 specification.

#+CAPTION: Browser scores for support of HTML5, from html5test.com on 01-05-2017.
#+NAME: table:browser-support
| Browser     | Score |
|-------------+-------|
| Chrome 57   |   519 |
| Firefox 52  |   474 |
| Edge 15     |   473 |
| Safari 10.1 |   406 |

# Open issue.
Using Electron to provide standalone applications is an open issue on the \thp{}
repository, issue ~#111~. There are three chronological steps to issue ~#111~.
The first step is using Electron to display a \thp{} application. The second
step is being able to package the \thp{} application as a standalone application
so that it can be easily distributed without having to compile code or even
touch the command line at all. Finally step three is to write a Haskell package
to automate the first two steps.

*** Electron Integration

# Integrating Electron is not so simple.
To display our \thp{} application with Electron we cannot simply ask a user to
download Electron's browser and view our \thp{} application with it. This is
because Electron's browser cannot be downloaded as a standalone application,
instead Electron provides an API for managing browser windows. Electron provides
its own JavaScript runtime which exposes this API. To open an Electron browser
window we have to write a JavaScript script that includes a call to the Electron
API that opens a browser window.

# Overview of script.
We wrote the necessary JavaScript script to display a \thp{} application using
Electron. The script executes the compiled \thp{} application, starting the
\thp{} application's server. The script waits until the server is running then
opens an Electron browser window with the URL pointing at the local server.
Finally the script manages shutdown of the application, for example we have to
consider the expected behaviour on macOS where clicking the red 'x' on an
application's window only closes the window but leave the process running.

# Electron Packager.
Electron Packager is a tool for packaging applications built with Electron into
standalone applications. Now that we have our \thp{} application being displayed
using Electron we can use Electron Packager to create a standalone application
for the current platform e.g. ~.deb~ packages for Debian or ~.app~ bundles for
macOS. The application produced is entirely standalone, including all necessary
dependencies such as the binaries of Electron and our \thp{} application, which
means it can be easily distributed. Instructions for creating standalone
applications of our \thp{} implementation of \utp{} were added to its README.

# TERM platform

# Pull Request.
We sent pull request #169 to the \thp{} repository. The pull request includes
the necessary script to display a \thp{} application using Electron, a guide on
how to integrate a \thp{} with Electron using the script, and a link to a
respository we setup which contains a minimal working example. After addressing
initial feedback the pull request was accepted. The pull request addresses the
first two steps of issue #111, it instructs users how to build and package
\thp{} applications with Electron but does not automate the process. The guide
in the pull request is included as an appendix.

#+BEGIN_QUOTE
"Thanks a lot for this!"

-- cite:Threepenny-guiPR169
#+END_QUOTE

*** Directory Selection

# A single attribute.
Now that our \thp{} application can be displayed using Electron, file selection
works correctly, however we still need to accomplish directory selection.
Revisiting Figure [[list:html-file-selector]] and [[list:html-directory-selector]] we
can see that the difference is only a single attribute, namely
~webkitdirectory~.

# Not set using \thp{}.
Setting attributes on a HTML element is done in \thp{} by calling a specific
function that \thp{} exposes for each attribute, for example to set a ~href~
attribute we could use \thp{}'s ~href~ function. The problem is that \thp{} does
not provide such a function W for the ~webkitdirectory~ attribute, nor does
\thp{} expose the functions that allow us write to write W ourselves.

# Fork and success.
We had to fork the \thp{} repository and expose the functions that allow us to
write W. A "fork" is a copy of a repository. With the fork of \thp{} we can
write the function W to set ~webkitdirectory~ on a file selector, turning it
into a directory selector. Figure [[fig:thp-workspace-dir]] shows a directory
selector in use in our \thp{} implementation of \utp{}, notice that files are
grayed out.

#+CAPTION: Workspace selection prompt in \utp{} implementation of \thp{}.
#+NAME: fig:thp-workspace-prompt
[[./images/workspace-select-1.png]]

#+CAPTION: Workspace directory selection, follows on from Figure [[fig:thp-workspace-prompt]].
#+NAME: fig:thp-workspace-dir
[[./images/workspace-select-2.png]]

** Functional Reactive Programming

*** Imperative or Reactive

Our \thp{} application will in some places refer to data which will change over
time, due to user input or for other reasons. For example, on the home screen an
element displays the current workspace directory, this value is initially unset
but receives a value once the user has selected a workspace. Updating elements
to reflect changes in their dependant data can be done in an imperative style or
reactive style.

#+CAPTION: Element displaying the current workspace.
#+NAME: list:frp-depends-data
#+BEGIN_SRC haskell
text <- UI.div # set UI.text "No workspace set"
#+END_SRC

#+CAPTION: Handling when a user selects a workspace.
#+NAME: list:frp-change-data
#+BEGIN_SRC haskell
on UI.valuechange selector $ \newWorkspace ->
  -- User selected a workspace, need to update elements.
#+END_SRC

# Imperative style.
In the imperative style, when we write an element that depends on changing data
e.g. Listing [[list:frp-depends-data]], we also write code to update that element
wherever the data changes e.g. Listing [[list:frp-change-data]]. The code declaring
the element and the code handling a change to the data may be in separate
modules, or at least separate to some degree. This separation is a violation of
the Law of Demeter, cite:hunt2000pragmatic, which says we should minimize
coupling between modules.

# Reactive style.
In the reactive style, when we write an element that depends on changing data we
write the element in terms of the /current/ value of that data. When the value
of the data changes over time our element will /react/ and update itself.
Consider some element we have written in terms of data held in a variable D. Now
the code handling a change to the data, such as Listing [[list:frp-change-data]],
simply updates D. Any elements which depend on D will be updated automatically,
see Figure [[fig:indirect-frp]]. Notably the code handling a change to the data does
not have to be concerned with elements depending on the data, we are no longer
violating the Law of Demeter.

#+BEGIN_QUOTE
"A remote part of the program may change the [element], and this "action at a
distance" is not visible at the point where the counter is declared. In
contrast, FRP specifies the whole dynamic behavior at the time of declaration"

-- cite:Threepenny-guiDesignWidgets
#+END_QUOTE

# Summary.
To summarise, functional reactive programming is preferable because when data
changes we do not have to worry about updating the elements that depend on that
data. Instead we update the elements indirectly, by emitting a new value of the
data which the elements then receive. By not updating the elements directly we
are not violating the Law of Demeter.

#+CAPTION: Using FRP we do not have to worry about updating elements.
#+NAME: fig:indirect-frp
#+ATTR_LATEX: :width 3.0in
[[./images/indirect-frp-1.png]]

*** FRP in \utp{}

# Where it is used.
Functional reactive programming is used in our \thp{} implementation of \utp{}
in two places. We use FRP to manage the current workspace directory and the
theory graph. In Figure [[fig:thp-utp-home]], a single-node theory graph can be seen
in our \thp{} implementation of \utp{}, the single node is labeled "\_ROOT$0".
The screenshot also shows the current workspace being displayed.

# Implementation.
This paragraph relates closely to Figure [[fig:indirect-frp]]. In each of the cases
where we use FRP, we have a variable that is accessible application-wide, which
represents the data over time. In the workspace directory's case the data is a
string, in the theory graph's case it is a tree structure. Whenever a new value
of the data is computed somewhere in the application, usually due to user input,
we emit that new value. For example when a user selects a workspace, we emit a
string, the file path of the workspace directory. If the data's value has
changed, any elements depending on the data will receive the new value and
update themselves.

#+CAPTION: Homescreen of \thp{} implementation of \utp{}.
#+NAME: fig:thp-utp-home
[[./images/workspace-select-3.png]]


** Implementing \utp{} with \thp{}

*** Abstract GUI Layer

# Abstract GUI layer.
The first attempt at building a GUI for \utp{} with \thp{} involved the notion
of an abstract GUI layer (AGL). We wanted to write the GUI for \utp{} in a
manner abstracted away from the specifics on any one GUI library. We hoped to
have the GUI only written once, GUI library agnostic, then we would plug-in
either of the GUI libraries, wxHaskell or \thp{}, to power the AGL.

# Implementation.
To implement this abstract GUI layer we wrote a set of generic functions for
things like creating a button or alerting a user. Our \utp{} application would
be written using these generic functions instead of functions from a specific
GUI library; again, allowing us to only write the GUI once.

# Typeclass.
The set of generic GUI functions were first written as an interface, so the
functions did not have an implementation, only their type signatures were
declared. This interface could then be implemented for each GUI library we want
the \utp{} application to support. The \utp{} application would be written using
the generic functions of the interface, which GUI library implementation would
actually be used would depend solely on which implementation we pass in as an
argument to our application.

# Difficulty: architecture differences.
Writing such an AGL proved difficult because of the different architectures of
wxHaskell and \thp{}. In particular we can wait for user input in wxHaskell,
while in \thp{} we cannot, in \thp{} we have to provide a callback that is
executed once the user provides input. This is not really \thp{}'s fault, it is
because some \thp{} code is compiled to JavaScript which runs in the browser's
event-loop, cite:swenson2013javascript. Because of the different architectures
of wxHaskell and \thp{}, it is difficult to capture some functionality with a
generic function.
 
*** Integration with Existing \utp{}
   
# Need for existing functions.
Since writing an abstract GUI layer proved difficult we attempted instead to
write a new GUI for \utp{} directly with \thp{}. In doing so we would like to
call some of the same functions that are called in the existing \utp{}
application, instead of writing them again. For example the existing \utp{}
application runs, on startup, a function called ~startupFileHandling~ is called
which ensures the workspace directory is correctly setup.

# Tightly coupled wxHaskell example.
The difficulty in reusing a function like ~startupFileHandling~ is the tight
integration of wxHaskell code. For example, ~startupFileHandling~ first checks
if a workspace is already setup, if not it asks the user which directory to use.
This user interaction takes the form of a wxHaskell input dialog. The tight
integration of wxHaskell code is problematic because our \thp{} application
cannot run wxHaskell code.

# Let's see how deep the rabbit hole goes?
~startupFileHandling~ delegates some work to other \utp{} functions which again
call other \utp{} functions, and so on such that we have a tree of \utp{}
functions called by ~startupFileHandling~. In this tree of functions, some of
the functions call wxHaskell code, which is not compatible with our \thp{}
application, this tree is shown in Figure [[fig:startup-tree]]. Another example of
wxHaskell code called, apart from the user input mentioned above, is when an
error occurs a wxHaskell error dialog is displayed.

#+CAPTION: Tree of functions with tight integration of wxHaskell code.
#+NAME: fig:startup-tree
[[./images/startupFileHandling.png]]

# Solution.
Because of the tight integration of wxHaskell code it requires some work to use
a function like ~startupFileHandling~ in our \thp{} application. To use
~startupFileHandling~ we need to rewrite the entire tree of functions below
~startupFileHandling~, replacing each call to a wxHaskell function, with a call
to a function that we provide as an argument to ~startupFileHandling~. This is
depicted in Figure [[fig:startup-GI]] and should be contrasted with Figure
[[fig:startup-tree]]. With this rewrite, ~startupFileHandling~ is now GUI library
independent. To use ~startupFileHandling~ in our \thp{} application we pass in
\thp{} functions as arguments, to use it in the existing \utp{} application we
pass in wxHaskell functions.

#+CAPTION: Making the functions in Figure [[fig:startup-tree]] GUI library independent.
#+NAME: fig:startup-GI
[[./images/startup-GI.png]]

** Conclusion

*** \utp{}

We explored the development of a second GUI for \utp{} using \thp{}. In this
exploration we made some progress of building a second GUI for \utp{} but still
have a lot to do. Notably we accomplished many of the core aspects of building a
GUI, building a right-click menu, writing a responsive layout, implementing file
and directory selection, and being able to create standalone applications. Where
appropriate we contributed some of our accomplishments to the \thp{} respository
or created a public library.

Building an entirely new GUI is a large undertaking and \thp{}'s youth really
showed in the process. However some of the difficulty in building a second GUI
for \utp{} using \thp{} was due to the tight integration of wxHaskell code in
the existing \utp{} application. Given that \utp{} already has a working GUI,
albeit with some rough edges, we believe that the fastest route to a polished
\utp{} application is by resolving the issues in the existing \utp{}
application.

*** \thp{}

# Benefits.
The \thp{} library has a lot of positive aspects to it, many of which arise due
to \thp{}'s core idea of using the web browser as a display. By using the web
browser as a display, \thp{} does not need to rely on another library to provide
support for displaying objects on-screen, in contrast with wxHaskell which
depends on the C++ library wxWidgets. Another advantage of \thp{} using the web
browser as a display is that we can leverage some of the many web development
libraries that exist, such as Materialize which we used to build the white
workspace selection prompt shown in Figure [[fig:thp-workspace-prompt]]. \thp{} also
has built-in support for FRP, it is easy to install, and if you have familiarity
with web technologies then it has quite a gentle learning curve.

# Disadvantages.
However \thp{} is a young library, and as we discovered, some things which might
be easy to accomplish in other GUI libraries were difficult with \thp{}. Two of
\thp{}'s shortcomings were a lack of support for building a right-click menu and
a file selector. Building a right-click menu was problematic because web
browsers have not yet implemented the respective specification, and implementing
file selection was tough because of a browser security feature that obfuscates
file paths. The difficulty in implementing these features stemmed from \thp{}
using the web browser as a display. So, while \thp{} using the web browser as a
display does provide the library with benefits it also creates issues.

# Issues, though the community can help.
It would be unusual for a young library like \thp{} not to have some issues.
Importantly though, the issues we discovered we were able be overcome. Key to
being able to address the issues was the reasonably small size of \thp{}'s code
base. \thp{}'s small size meant we did not need to spend much time figuring out
the code to reach the point where we could write our own fixes. This ability for
the community to get involved reduces stress on the core maintainers and is key
to the projects growth.

# Maintainability and growth.
In addition to enabling the community to get involved, \thp{}'s small size means
it is highly maintainable. The combination of being highly maintainable and the
ability of the community to get involved is why we believe \thp{} has a great
chance of surviving to maturity and growing into a popular Haskell GUI library,
which the Haskell GUI space is in need of. For these reasons we remain highly
positive about \thp{}'s future.

* LaTeX                                                              :ignore:

\appendix

* Appendices

** Code Produced

The \thp{] implementation of \utp{} we produced can be found on GitHub at:

https://github.com/andrewbutterfield/utp2/tree/feature/threepenny-gui

Any interactions with the \thp{} repository, including pull requests and issues
can be found on GitHub at:

https://github.com/HeinrichApfelmus/threepenny-gui/issues?q=author%3Abarischj%20

The \tgc{} library we produced can be found on GitHub at:

https://github.com/barischj/threepenny-gui-contextmenu

The \tgf{} library we produced can be found on GitHub (source) and Hackage
(documentation) at:

https://github.com/barischj/threepenny-gui-flexbox

http://hackage.haskell.org/package/threepenny-gui-flexbox/docs/Graphics-UI-Threepenny-Ext-Flexbox.html

** Pull Requests and Issues

*** Pull Requests

The following pull requests were accepted into the \thp{} repository.

| Number | Description                                                               |
|--------+---------------------------------------------------------------------------|
|    147 | Support for a contextmenu event, allowing us to build a right-click menu. |
|    162 | Bump Stack resolver to next major version.                                |
|    168 | Use high-quality badge for Travis build status.                           |
|    169 | Added Electron integration guide for \thp{}.                              |
|    173 | Added MonadUI typeclass.                                                  |

*** Issues

The following issues were opened on the \thp{} repository.

| Number | Description                                                                     |
|--------+---------------------------------------------------------------------------------|
|    146 | Guide for writing "widgets" in \thp{} is unfinished.                            |
|    167 | Suggested a new design for returning event data from the browser to the server. |
|    170 | Functions for writing our own attribute setting functions are not exposed.      |
|    171 | "valueChange" event is not fired until user presses ESC.                        |

** Electron Integration Guide for \thp{} 

The Electron integration guide for \thp{}, in pull request #169. Compiled from
GitHub markdown to LaTeX using ~pandoc~.

\ornamentbreak

#+INCLUDE: "./pr169.org" :minlevel 3

** threepenny-gui-contextmenu
   
README of the Haskell package \tgf{}. Compiled from GitHub markdown to LaTeX
using ~pandoc~.

\ornamentbreak

#+INCLUDE: "./threepenny-gui-contextmenu.org" :minlevel 3

** threepenny-gui-flexbox

README of the Haskell package \tgf{}. Compiled from GitHub markdown to LaTeX
using ~pandoc~.

\ornamentbreak

#+INCLUDE: "./threepenny-gui-flexbox.org" :minlevel 3

* LaTeX                                                              :ignore:

bibliography:~/bibliography/references.bib
