#+LATEX_CLASS: report
#+LATEX_HEADER: \include{settings/preamble}
#+LATEX_HEADER: \usepackage{parskip}
#+OPTIONS: toc:nil

# \usepackage{draftwatermark}

\inserttitlepage

\pagenumbering{roman}
\setcounter{page}{1}

\declaration

\permissiontolend

\setcounter{page}{3}
\insertabstract

# Need to fiddle with page numbers manually to make them consistent
\setcounter{page}{4}
\acknowledgements

\tableofcontents

\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

* Background
** Existing Software

\utp{} is an existing computer application which is a Theorem Proving Assistant
for the Unifying Theory of Programming. "Theorem Proving Assistant" means it can
be used to assist the development of theorems, the theorems in question are
related to the "Unifying Theory of Programming". The application is written in
Haskell, with a graphical user interface (GUI) built with the mature wxHaskell
library. \utp{} has been in development since at least March 2010 which is when
the source originally appears on BitBucket. \utp{} was formerly known as
SaoithÃ­n.

WxHaskell is a GUI library for Haskell that was started in July 2003 REF but
moved to its current repository in January 2007 REF when the project was taken
over by a new set of maintainers. The goal of the project is to provide an
"industrial strength GUI library" for Haskell REF. The wxHaskell team attempt to
do so by building on top of an existing GUI library REF, and thus avoid the
majority of the burden of developing a GUI library themselves REF.

\begin{center}
  \includegraphics[scale=0.7]{images/existing-utp2-home-screen.png}
\end{center}

** Existing Issues
*** Object Oriented Concepts

wxHaskell is built on top of an existing GUI library called wxWidgets. However
wxHaskell is a GUI library for Haskell and wxWidgets is a GUI library for C++,
and Haskell and C++ are very different languages, Haskell is a functional
programming language and C++ is an object oriented language. Unfortunately
wxHaskell exposes the object oriented concept of inheritance to the programmer
and wxHaskell code is typically written using about twenty percent low level
bindings to wxWidgets.

In wxWidgets inheritance is used to describe the type of many components. For
example a button in wxWidgets has a type ~wxButton~ but it has many layers of
inheritance as you can see in the image below. Because wxHaskell is a wrapper
around wxWidgets some concepts from wxWidgets appear in wxHaskell, in the case
of a button its type in wxHaskell is ~Window (CControl (CButton ()))~ which
encodes some of the inheritance relationship.

wxHaskell consists of four key libraries, only two of which are typically used
by a wxHaskell programmer. The lesser used of these is wxcore which is a set of
low-level Haskell bindings to wxc where wxc is a C language binding for
wxWidgets. The more used is wx which is a set of higher-level wrappers over
wxcore. Most wxHaskell software is about eighty percent wx and twenty percent
wxcore.

# REF https://wiki.haskell.org/Haskell

We have described how wxHaskell exposes object oriented concepts of the
wxWidgets library which it wraps, both through encoding inheritance and the
low-level bindings of wxcore. The reason all of this is unfavourable is because
as programmers we have some choice in the languages we use, and a functional
language like Haskell is chosen because it makes it easier to produce flexible,
maintainable, high-quality software REF. Re-introducing concepts from languages
that were not chosen is a compromise. Analogously if you were an object oriented
programmer and were told that you are now only allowed to use sequential
statements you probably would not be too happy.

While we can argue the merits of functional programming it is worth noting that
Haskell and C++ are two solutions to different problems, they each solve their
share of problems equally well. Haskell provides a high level of abstraction and
few runtime errors while C++ provides fast execution time and a lot of library
support. However if you have chosen a language to work with you should be able
to stay within its constructs and paradigms.

# Inheritance is a feature from object oriented languages and is not generally
# dealt with in functional programming. Consider in an object oriented language a
# type ~FooA~ which inherits from ~Foo~. If we wanted to model something similar
# in a functional programming language like Haskell, but avoiding any object
# oriented concepts, then we could write a function ~foo~ which returns data of
# type ~Foo~ and then write a function ~fooA~ which internally calls ~foo~ but
# modifies the data (a ~Foo~) first before returning a ~FooA~. The key point here
# is that we do not need inheritance to get the data we ultimately want to
# represent, both languages simply present different techniques for representing
# and modifying the data.

*** Difficult to Install

# TERM sandbox

Ease of downloading and installing libraries into sandboxes has become a staple
of modern languages, with many modern languages like Rust, Swift and Elixir
shipping with powerful package managers that automate this process. Haskell has
made progress on this front with the package manager Stack.

Before Stack existed it was not uncommon to be stuck with dependency conflicts
between libraries that your project depends on. Dependency conflicts occur when
libraries have conflicting version bounds on some mutually required library. For
example if library-a requires library-c > 0.7 but library-b requires library-c <
0.7 then we have a dependency conflict since no version of library-c can satisfy
both conditions. You might end up changing the version of library-a to a
previous version that requires library-c 0.6 which then satisfies both
conditions, however, now library-a also requires library-d 0.5 but library-c
requires library-d > 0.6. This endless cycle of fixing dependency conflicts is
commonly referred to as Cabal hell.

The Haskell tool Stack solves Cabal hell by providing sets of libraries which
are guaranteed to work together without dependency conflicts. These sets of
libraries are called resolvers and every week on Sunday night a new stable
resolver is released. Using Stack we can easily add a dependency to a Haskell
project by simply listing it in the project's dependencies. The next time the
project is built using Stack the new dependency will automatically be downloaded
and built to a location in a sandbox designated for the project.

wxHaskell is not in the current Stack resolver (we commonly just say "in
Stack"). This means if we want to build our project with the tool Stack, then
wxHaskell has to be listed as an additional dependency, and there are no
guarantees of avoiding conflicts with wxHaskell's dependencies. At the beginning
of this final year project \utp{} was not building with Stack at all but rather
had to built by directly invoking the GHC compiler. Andrew Butterfield later
succeeded in getting the project building with Stack, the significance of which
is reflected in the relevant commit message:

#+BEGIN_QUOTE
UTP2 NOW BUILDS WITH stack ON OS X 10.11.16 !!!!
#+END_QUOTE

It is worth noting two things here. One is that the difficulty of getting \utp{}
to build with Stack was because of dependencies like wxHaskell which are not in
Stack and caused dependency conflicts. The second is that there are benefits to
Stack apart from its resolvers, including isolated and reproducible builds, and
an easy to use command line interface.

However installing wxHaskell is not /just/ a matter of resolving dependency
conflicts. We also need to install the C++ library wxWidgets which wxHaskell is
a wrapper around. The instructions for installing wxWidgets are different per
platform due to their not being a well-established C++ package manager.
Furthermore, on macOS, installing wxWidgets requires an install of the
application XCode which on my machine weighs in at 10.46GB.

*** Difficult to Package

A goal of Andrew Butterfield's while developing \utp{} was to reach a point
where operating system native applications of \utp{} could be distributed
e.g. ~.deb~ packages for Debian or ~.app~ bundles for macOS, or if not native
applications then at least executables. This proved difficult for the existing
project as it was not being successfully built on macOS and was difficult to
build on Linux, however executables for Windows do exist and are hosted on the
project's homepage. At least on macOS the difficulties in building the project
are largely related to wxHaskell, for reasons discussed in the previous section
2.2.

#+BEGIN_QUOTE
Students at TCD have successfully built it on Linux (Ubuntu). It should run in
principle on Max OS X as well, but I have not been able to get this to work
(help would be appreciated).

    -- scss.tcd.ie/Andrew.Butterfield/Saoithin
#+END_QUOTE

*** Conclusion

In respect of the object oriented concepts exposed by the wxHaskell library, and
the difficulty in building \utp{} and creating operating system native
applications of \utp{} -- in both of which wxHaskell plays a role -- I decided
to attempt building a GUI for \utp{} using an alternative GUI library, one I
hoped would alleviate all of the problems associated with wxHaskell.

** A New Hope
*** Haskell GUI Libraries

Unfortunately the state of GUI programming in Haskell is not in a great place.
There do exist many GUI libraries but they tend to fall into one of two
categories. Some provide direct access to GUI facilities through bindings to an
imperative library, wxHaskell falls into this category. Most of the more
powerful GUI libraries fall into this category, because they can leverage the
existing power of the imperative language they provide a binding to. Others
present more high-level programming interfaces, and have a more declarative,
functional feel. These libraries tend to not provide GUI support directly but
rely on a library like wxHaskell to provide the necessary GUI bindings.

# REF http://conal.net/papers/genuinely-functional-guis.pdf

#+BEGIN_QUOTE
There is a large number of GUI libraries for Haskell. Unfortunately there is no
standard one and all are more or less incomplete. In general, low-level veneers
are going well, but they are low level. High-level abstractions are pretty
experimental. There is a need for a supported medium-level GUI library.

    -- wiki.haskell.org/Applications_and_libraries/GUI_libraries
#+END_QUOTE

*** \thp{}

# How Threepenny fits into the Haskell GUI scene.
\thp{} is a GUI library for Haskell which falls into the previously mentioned
second category, it provides high-level abstractions with a declarative,
functional feel. However it does not rely on another library like wxHaskell to
provide GUI bindings, \thp{} is a stand-alone GUI library. As a stand-alone GUI
library \thp{} does not rely on any non-Haskell dependencies, in stark contrast
with wxHaskell.

# Avoiding GUI dependencies.
How does \thp{} display things on-screen? \thp{} does not create bindings to any
system calls to display a GUI, this means that \thp{} applications are not
operating system native applications. \thp{}'s key distinguishing factor is that
it uses the web browser as a display. Web pages like docs.google.com are
examples of powerful web applications, applications that use the web browser to
display a GUI. There are many powerful web applications that provide an
experience that is not compromised because the application was written as a web
application instead of as an operating system native application. A notable part
of the experience when using a web application like Google Docs is that an
installation is not required, a web browser which is the necessary software to
display the GUI, is something which most people already have installed. \thp{}
manages to avoid relying on another Haskell library for GUI bindings, and
manages to avoid any non-Haskell dependencies. It does so by requiring a piece
of software to display a GUI that most people already have installed, a web
browser.

# Easy installation.
Because \thp{} manages to avoid GUI related dependencies, by using the web
browser as a display, the pain of installing these dependencies is removed and
installing \thp{} is easy. At the time \thp{} was chosen it was not in Stack,
however only one of its dependencies was not in a Stack. Once a library's entire
dependencies are in Stack it is trivial to get that library in Stack. A few
weeks after discovering \thp{} it was in the latest Stack resolver.

# Full power of modern web development.
Because \thp{} uses the web browser as a display, this means that what is being
rendered to the user is ultimately just HTML and CSS. How \thp{} works is that
it provides functions to write and manipulate HTML, it also allows the
programmer to load CSS files and to run JavaScript. How \thp{} works will be
explained in more detail later on but in essence it is a wrapper around the
languages of modern web development, this means the full power of modern
development can be leveraged in a \thp{} application. Another benefit of \thp{}
being a wrapper around HTML, CSS and JavaScript is that if you are familiar with
these web development technologies then \thp{} has a relatively gentle learning
curve compared to other Haskell GUI libraries.

# FRP.
We have mentioned that \thp{} provides high-level abstractions, with a
declarative, functional feel. This is largely due a concept called Functional
Reactive Programming (FRP) which is at the heart of \thp{}. FRP will be
explained in more detail later on, for now it is sufficient to know that FRP is
a style of programming which is very much in line with the functional
programming ideology, of declarative high-level semantics. Heinrich Apfelmus is
the author of a popular FRP library for Haskell named reactive-banana. Apfelmus
created \thp{} to explore the application of FRP to building a GUI.

*** \thp{} for \utp{}
    
# Why Threepenny summary.
\thp{} was chosen for \utp{} because of the above reasons. It is easy to
install, in stark contrast to wxHaskell. It has a gentle learning curve if you
are already familiar with web development technologies. Finally, the strong
focus on FRP within \thp{} promotes writing a GUI in a declarative manner, in a
style in-line with the functional programming ideology.

# Young, flawed but maintainable.
While \thp{} has these many benefits it is still a young library and would
likely have some flaws, which would later be confirmed. \thp{} was only started
in July 2013 and at the current time of writing is on version 0.7.1. However,
for a functioning GUI library \thp{} has quite a small code base which makes it
easier to get involved and find solutions to these flaws. The small code base
also means that \thp{} is very maintainable which is vital for its longevity.
Part of the reason for the small code base is the fact that \thp{} leverages the
power of existing web development technologies, letting these existing and
widely prevalent technologies do the heavy lifting.

** \thp{}

*** Introduction

# Reference section.
As the project progressed flaws of \thp{} were discovered and addressed. This
required making modifications to \thp{}'s source code. In light of this it is
beneficial to have a deeper understanding of how \thp{} operates, which will
make understanding \thp{}'s flaws and how they were addressed much easier later
on. This chapter provides an overview of how \thp{} operates and then provides
an in-depth walk-through of a small \thp{} application.

*** Overview 

# Browser as a display.
\thp{} uses the web browser as a display. This means that a user views a \thp{}
application in their browser, and what is rendered in their browser is HTML and
CSS, which can be manipulated by JavaScript. To solidify this idea that a \thp{}
application is ultimately HTML and CSS the screenshot below shows a simple
\thp{} application being displayed in a web browser. The web browser's developer
tools are open to show the HTML structure of the application.

# TODO Screenshot

# Manipulations by JavaScript.
The screenshot above shows how a \thp{} application consists of HTML. However it
only shows a static view of the application and applications generally need to
be dynamic; the displayed HTML needs to be able to change in structure, in
response to user input for example. These manipulations are done in the browser
by JavaScript. Any \thp{} code which manipulates HTML is converted from Haskell
to JavaScript and evaluated in the web browser. For example we might want to
append a list item ~<li>~ with text "Ferrari" to a list ~<ul>~ of car names, and
have written the appropriate Haskell code (below). At runtime this Haskell code
is converted to JavaScript and evaluated in the browser.

#+BEGIN_SRC Haskell
UI.ul #+ [UI.li # set UI.text "Ferrari"]
#+END_SRC
*Appending to a list in \thp{}*

# Event loop.
So far we have covered the ideas that \thp{} applications are displayed as HTML
and CSS in a web browser, and that manipulations occur by converting Haskell
code to JavaScript and evaluating it in the web browser. One important question
is how a \thp{} application knows when to apply the manipulations, when to
evaluate the JavaScript? For example we might only want the colour of a HTML
element to change when the user presses a specific button, in this case we are
waiting for input from the user and once that input is received JavaScript is
evaluated. Wherever our \thp{} application is interested in a certain event,
such as a user pressing a button, interest in that event is registered with the
web browser which is displaying the application. Whenever the event occurs in
the browser, the \thp{} application is informed and may send additional
JavaScript code to the browser to be evaluated.

*** Walkthrough

# Overview.
We now have an overview of how a \thp{} application is displayed in the browser,
including conversion to JavaScript code and how browser events such as button
clicks are handled. We will now look at the life-cycle of a \thp{} in more
detail, by looking at a minimal working \thp{} application. While working our
way through the application we will be referring to the image below which
describes the life-cycle of a \thp{} application.

\begin{center}
  \includegraphics[scale=0.15]{images/threepenny-run-ui.png}
\end{center}

*Life-cycle of a \thp{} Application*

# The minimal application.
The Haskell code of the \thp{} application we are looking at is below. In
particular we are concerned with the four lines of the body of the function
~app~. The remaining code is boilerplate to achieve a full working application.
The first line of ~app~ creates a button with text "Click me!". In the second
line we attach that button to the HTML ~<body>~.

# TERM boilerplate

#+BEGIN_SRC Haskell
module Main where

import qualified Graphics.UI.Threepenny      as UI
import           Graphics.UI.Threepenny.Core

main = startGUI defaultConfig app

app window = do
  button <- UI.button # set UI.text "Click me!"
  getBody window #+ [element button]
  on UI.click button $ const $
    element button # set UI.text "I have been clicked!"
#+END_SRC

We have described the application code at a high-level, now we will look in more
detail at what occurs at runtime. When we execute the compiled code a local HTTP
server is started, the server serves at the address ~localhost:8000~ by default.
We can visit this address in our browser to view the \thp{} application. When we
visit ~localhost:8000~ in our browser a HTTP GET request is sent to the server
and the server responds with some HTML. This corresponds to the first two arrows
in our life cycle diagram.

Included in the HTML is some JavaScript which is evaluated in the browser and
opens a connection to the server. This is the third arrow in our life cycle
diagram. The type of connection opened is called a WebSocket connection and it
stays open until the user closes their browser tab. The benefit of maintaining
an open connection between the server and the browser is that the server can
send data to the browser whenever it wants to, this means the server can update
what is being displayed at any time. For example we might want to set a button
to a red colour after a timer expires. Because a WebSocket connection is open,
the server can send JavaScript code to the browser when the timer expires, this
JavaScript code is evaluated in the browser and sets the button to a red colour.
To further see why maintaining an open connection is important we can consider
the alternative. In a traditional web application the browser sends HTTP
requests to the server and the server responds, the server can only send data to
the browser in response to a browser's HTTP request. Considering our timer
example, for the browser to colour the button red when the timer expires the
browser would have to be polling the server.

Continuing with our example application, once the WebSocket connection has been
opened our \thp{} application code is evaluated, this corresponds with the
fourth arrow in our life cycle diagram. In the second line of ~app~, JavaScript
code is sent from the server to the browser to be evaluated, this code adds the
button element from the first line to the HTML ~<body>~. In the third line the
server tells the browser that it should be informed of any clicks on the button.

Finally we will consider the loop in the life cycle diagram. The browser informs
the server whenever the button click event occurs, this corresponds to the fifth
arrow in the life cycle diagram. When the server receives this information the
fourth line of ~app~ is run, sending JavaScript code to the browser to change
the buttons text to "I have been clicked!" which corresponds to the final arrow
of the life cycle diagram. This event loop will continue until either the user
closes the browser tab or the server is killed.

* Implementation

** A Right-Click Menu
   
** Layout Combinators

** File Selection
   
** Electron

** Electron Packager

** Directory Selection

** Functional Reactive Programming

** Abstract GUI Layer

** Conflicting Architectures
   
** Web Development Libraries

* Reflections

** Edit-Compile-Evaluate

** Conclusion

\insertbibliography

\appendix
