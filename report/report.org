#+LATEX_CLASS: report
#+LATEX_HEADER: \include{settings/preamble}
#+LATEX_HEADER: \usepackage{parskip}
#+OPTIONS: toc:nil

# \usepackage{draftwatermark}

\inserttitlepage

\pagenumbering{roman}
\setcounter{page}{1}

\declaration

\permissiontolend

\setcounter{page}{3}
\insertabstract

# Need to fiddle with page numbers manually to make them consistent
\setcounter{page}{4}
\acknowledgements

\tableofcontents

\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

* Background
** Existing Software

\utp{} is an existing computer application which is a Theorem Proving Assistant
for the Unifying Theory of Programming. "Theorem Proving Assistant" means it can
be used to assist the development of theorems, the theorems in question are
related to the "Unifying Theory of Programming". The application is written in
Haskell, with a graphical user interface (GUI) built with the mature wxHaskell
library. \utp{} has been in development since at least March 2010 which is when
the source originally appears on BitBucket. \utp{} was formerly known as
SaoithÃ­n.

TODO title

\includegraphics{images/existing-utp2-home-screen.png}

WxHaskell is a GUI library for Haskell that was started in July 2003 REF but
moved to its current repository in January 2007 REF when the project was taken
over by a new set of maintainers. The goal of the project is to provide an
"industrial strength GUI library" for Haskell REF. The wxHaskell team attempt to
do so by building on top of an existing GUI library REF, and thus avoid the
majority of the burden of developing a GUI library themselves REF.

** Existing Issues
*** Object Oriented Concepts

wxHaskell is built on top of an existing GUI library called wxWidgets. However
wxHaskell is a GUI library for Haskell and wxWidgets is a GUI library for C++,
and Haskell and C++ are very different languages, Haskell is a functional
programming language and C++ is an object oriented language. Unfortunately
wxHaskell exposes the object oriented concept of inheritance to the programmer
and wxHaskell code is typically written using about twenty percent low level
bindings to wxWidgets.

In wxWidgets inheritance is used to describe the type of many components. For
example a button in wxWidgets has a type ~wxButton~ but it has many layers of
inheritance as you can see in the image below. Because wxHaskell is a wrapper
around wxWidgets some concepts from wxWidgets appear in wxHaskell, in the case
of a button its type in wxHaskell is ~Window (CControl (CButton ()))~ which
encodes some of the inheritance relationship.

wxHaskell consists of four key libraries, only two of which are typically used
by a wxHaskell programmer. The lesser used of these is wxcore which is a set of
low-level Haskell bindings to wxc where wxc is a C language binding for
wxWidgets. The more used is wx which is a set of higher-level wrappers over
wxcore. Most wxHaskell software is about eighty percent wx and twenty percent
wxcore.

# REF https://wiki.haskell.org/Haskell

We have described how wxHaskell exposes object oriented concepts of the
wxWidgets library which it wraps, both through encoding inheritance and the
low-level bindings of wxcore. The reason all of this is unfavourable is because
as programmers we have some choice in the languages we use, and a functional
language like Haskell is chosen because it makes it easier to produce flexible,
maintainable, high-quality software REF. Re-introducing concepts from languages
that were not chosen is a compromise. Analogously if you were an object oriented
programmer and were told that you are now only allowed to use sequential
statements you probably would not be too happy.

While we can argue the merits of functional programming it is worth noting that
Haskell and C++ are two solutions to different problems, they each solve their
share of problems equally well. Haskell provides a high level of abstraction and
few runtime errors while C++ provides fast execution time and a lot of library
support. However if you have chosen a language to work with you should be able
to stay within its constructs and paradigms.

# Inheritance is a feature from object oriented languages and is not generally
# dealt with in functional programming. Consider in an object oriented language a
# type ~FooA~ which inherits from ~Foo~. If we wanted to model something similar
# in a functional programming language like Haskell, but avoiding any object
# oriented concepts, then we could write a function ~foo~ which returns data of
# type ~Foo~ and then write a function ~fooA~ which internally calls ~foo~ but
# modifies the data (a ~Foo~) first before returning a ~FooA~. The key point here
# is that we do not need inheritance to get the data we ultimately want to
# represent, both languages simply present different techniques for representing
# and modifying the data.

*** Difficult to Install

# TERM sandbox

Ease of downloading and installing libraries into sandboxes has become a staple
of modern languages, with many modern languages like Rust, Swift and Elixir
shipping with powerful package managers that automate this process. Haskell has
made progress on this front with the package manager Stack.

Before Stack existed it was not uncommon to be stuck with dependency conflicts
between libraries that your project depends on. Dependency conflicts occur when
libraries have conflicting version bounds on some mutually required library. For
example if library-a requires library-c > 0.7 but library-b requires library-c <
0.7 then we have a dependency conflict since no version of library-c can satisfy
both conditions. You might end up changing the version of library-a to a
previous version that requires library-c 0.6 which then satisfies both
conditions, however, now library-a also requires library-d 0.5 but library-c
requires library-d > 0.6. This endless cycle of fixing dependency conflicts is
commonly referred to as Cabal hell.

The Haskell tool Stack solves Cabal hell by providing sets of libraries which
are guaranteed to work together without dependency conflicts. These sets of
libraries are called resolvers and every week on Sunday night a new stable
resolver is released. Using Stack we can easily add a dependency to a Haskell
project by simply listing it in the project's dependencies. The next time the
project is built using Stack the new dependency will automatically be downloaded
and built to a location in a sandbox designated for the project.

wxHaskell is not in the current Stack resolver (we commonly just say "in
Stack"). This means if we want to build our project with the tool Stack, then
wxHaskell has to be listed as an additional dependency, and there are no
guarantees of avoiding conflicts with wxHaskell's dependencies. At the beginning
of this final year project \utp{} was not building with Stack at all but rather
had to built by directly invoking the GHC compiler. Andrew Butterfield later
succeeded in getting the project building with Stack, the significance of which
is reflected in the relevant commit message:

#+BEGIN_QUOTE
UTP2 NOW BUILDS WITH stack ON OS X 10.11.16 !!!!
#+END_QUOTE

It is worth noting two things here. One is that the difficulty of getting \utp{}
to build with Stack was because of dependencies like wxHaskell which are not in
Stack and caused dependency conflicts. The second is that there are benefits to
Stack apart from its resolvers, including isolated and reproducible builds, and
an easy to use command line interface.

However installing wxHaskell is not /just/ a matter of resolving dependency
conflicts. We also need to install the C++ library wxWidgets which wxHaskell is
a wrapper around. The instructions for installing wxWidgets are different per
platform due to their not being a well-established C++ package manager.
Furthermore, on macOS, installing wxWidgets requires an install of the
application XCode which on my machine weighs in at 10.46GB.

*** Difficult to Package

A goal of Andrew Butterfield's while developing \utp{} was to reach a point
where operating system native applications of \utp{} could be distributed
e.g. ~.deb~ packages for Debian or ~.app~ bundles for macOS, or if not native
applications then at least executables. This proved difficult for the existing
project as it was not being successfully built on macOS and was difficult to
build on Linux, however executables for Windows do exist and are hosted on the
project's homepage. At least on macOS the difficulties in building the project
are largely related to wxHaskell, for reasons discussed in the previous section
2.2.

#+BEGIN_QUOTE
Students at TCD have successfully built it on Linux (Ubuntu). It should run in
principle on Max OS X as well, but I have not been able to get this to work
(help would be appreciated).

    -- scss.tcd.ie/Andrew.Butterfield/Saoithin
#+END_QUOTE

*** Conclusion

In respect of the object oriented concepts exposed by the wxHaskell library, and
the difficulty in building \utp{} and creating operating system native
applications of \utp{} -- in both of which wxHaskell plays a role -- I decided
to attempt building a GUI for \utp{} using an alternative GUI library, one I
hoped would alleviate all of the problems associated with wxHaskell.

** A New Hope
*** Haskell GUI Libraries

Unfortunately the state of GUI programming in Haskell is not in a great place.
There do exist many GUI libraries but they tend to fall into one of two
categories. Some provide direct access to GUI facilities through bindings to an
imperative library, wxHaskell falls into this category. Most of the more
powerful GUI libraries fall into this category, because they can leverage the
existing power of the imperative language they provide a binding to. Others
present more high-level programming interfaces, and have a more declarative,
functional feel. These libraries tend to not provide GUI support directly but
rely on a library like wxHaskell to provide the necessary GUI bindings.

# REF http://conal.net/papers/genuinely-functional-guis.pdf

#+BEGIN_QUOTE
There is a large number of GUI libraries for Haskell. Unfortunately there is no
standard one and all are more or less incomplete. In general, low-level veneers
are going well, but they are low level. High-level abstractions are pretty
experimental. There is a need for a supported medium-level GUI library.

    -- wiki.haskell.org/Applications_and_libraries/GUI_libraries
#+END_QUOTE

*** \thp{}

# How Threepenny fits into the Haskell GUI scene.
\thp{} is a GUI library for Haskell which falls into the previously mentioned
second category, it provides high-level abstractions with a declarative,
functional feel. However it does not rely on another library like wxHaskell to
provide GUI bindings, \thp{} is a stand-alone GUI library. As a stand-alone GUI
library \thp{} does not rely on any non-Haskell dependencies, in stark contrast
with wxHaskell.

# Avoiding GUI dependencies.
How does \thp{} display things on-screen? \thp{} does not create bindings to any
system calls to display a GUI, this means that \thp{} applications are not
operating system native applications. \thp{}'s key distinguishing factor is that
it uses the web browser as a display. Web pages like docs.google.com are
examples of powerful web applications, applications that use the web browser to
display a GUI. There are many powerful web applications that provide an
experience that is not compromised because the application was written as a web
application instead of as an operating system native application. A notable part
of the experience when using a web application like Google Docs is that an
installation is not required, a web browser which is the necessary software to
display the GUI, is something which most people already have installed. \thp{}
manages to avoid relying on another Haskell library for GUI bindings, and
manages to avoid any non-Haskell dependencies. It does so by requiring a piece
of software to display a GUI that most people already have installed, a web
browser.

# Easy installation.
Because \thp{} manages to avoid GUI related dependencies, by using the web
browser as a display, the pain of installing these dependencies is removed and
installing \thp{} is easy. At the time \thp{} was chosen it was not in Stack,
however only one of its dependencies was not in a Stack, a library called
~warp~. Once a library's entire dependencies are in Stack it is trivial to get
that library in Stack. Shortly later ~warp~ and subsequently \thp{} were in
Stack.

# Full power of modern web development.
Because \thp{} uses the web browser as a display, this means that what is being
rendered to the user is ultimately just HTML, CSS and JavaScript. How \thp{}
works is that it provides functions to manipulate HTML, it also allows the
programmer to load CSS and to run JavaScript. How \thp{} works will be explained
in more detail later on but in essence it is a wrapper around the languages of
modern web development, this means the full power of modern development can be
leveraged in a \thp{} application. Another benefit of \thp{} being a wrapper
around HTML, CSS and JavaScript is that if you are familiar with these web
development technologies then \thp{} has a relatively gentle learning curve
compared to other Haskell GUI libraries.

# FRP.
We have mentioned that \thp{} provides high-level abstractions, with a
declarative, functional feel. This is largely due a concept called Functional
Reactive Programming (FRP) which is at the heart of \thp{}. FRP will be
explained in more detail later on, for now it is sufficient to know that FRP is
a style of programming which is very much in line with the functional
programming ideology, of declarative high-level semantics. Heinrich Apfelmus is
the author of a popular FRP library for Haskell named reactive-banana. Apfelmus
created \thp{} to explore the application of FRP to building a GUI.

*** \thp{} for \utp{}
    
# Why Threepenny summary.
\thp{} was chosen for \utp{} because of the above reasons. It is easy to
install, in stark contrast to wxHaskell. It has a gentle learning curve if you
are already familiar with web development technologies. Finally, the strong
focus on FRP within /thp{} promotes writing a GUI in a declarative manner, in a
style in-line with the functional programming ideology.

# Young, flawed but maintainable.
While \thp{} has these many benefits it is still a young library and would
likely have some flaws, which would later be confirmed. \thp{} was only started
in July 2013 and at the current time of writing is on version 0.7.1. However,
for a functioning GUI library it has quite a small code base which would make it
easier to get involved with \thp{} to find solutions to these flaws. The small
code base also means that \thp{} is very maintainable which is vital for its
longevity. Part of the reason for the small code base is the fact that \thp{}
leverages the power of existing web development technologies, letting these
existing and widely prevalent technologies do the heavy lifting.

* \thp{}

*** Introduction

# Reference section.
As the project progressed flaws of thp{} were discovered and addressed. This
required making modifications to \thp{}'s source code. In light of this it is
beneficial to have a deeper understanding of how \thp{} operates. This will make
understanding \thp{}'s flaws and how they were addressed much easier later on.

*** Overview 

# Browser as a display.

# 

*** Walkthrough

* Implementation

* Reflections

\insertbibliography

\appendix
